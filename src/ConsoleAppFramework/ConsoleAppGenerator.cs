using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Reflection;

namespace ConsoleAppFramework;

[Generator(LanguageNames.CSharp)]
public partial class ConsoleAppGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(EmitConsoleAppTemplateSource);

        // ConsoleApp.Run
        var runSource = context.SyntaxProvider
            .CreateSyntaxProvider((node, ct) =>
            {
                if (node.IsKind(SyntaxKind.InvocationExpression))
                {
                    var invocationExpression = (node as InvocationExpressionSyntax);
                    if (invocationExpression == null) return false;

                    var expr = invocationExpression.Expression as MemberAccessExpressionSyntax;
                    if ((expr?.Expression as IdentifierNameSyntax)?.Identifier.Text == "ConsoleApp")
                    {
                        var methodName = expr?.Name.Identifier.Text;
                        if (methodName is "Run" or "RunAsync")
                        {
                            return true;
                        }
                    }

                    return false;
                }

                return false;
            }, (context, ct) => new RunContext((InvocationExpressionSyntax)context.Node, context.SemanticModel))
            .WithTrackingName("ConsoleApp.Run.0_CreateSyntaxProvider"); // annotate for IncrementalGeneratorTest

        context.RegisterSourceOutput(runSource, EmitConsoleAppRun);

        // ConsoleAppBuilder
        var builderSource = context.SyntaxProvider
            .CreateSyntaxProvider((node, ct) =>
            {
                ct.ThrowIfCancellationRequested();
                if (node.IsKind(SyntaxKind.InvocationExpression))
                {
                    var invocationExpression = (node as InvocationExpressionSyntax);
                    if (invocationExpression == null) return false;

                    var expr = invocationExpression.Expression as MemberAccessExpressionSyntax;
                    var methodName = expr?.Name.Identifier.Text;
                    if (methodName is "Add" or "UseFilter" or "Run" or "RunAsync")
                    {
                        return true;
                    }

                    return false;
                }

                return false;
            }, (context, ct) => new BuilderContext(
                (InvocationExpressionSyntax)context.Node,
                ((context.Node as InvocationExpressionSyntax)!.Expression as MemberAccessExpressionSyntax)!.Name.Identifier.Text,
                context.SemanticModel,
                ct))
            .WithTrackingName("ConsoleApp.Builder.0_CreateSyntaxProvider")
            .Where(x =>
            {
                var model = x.Model.GetTypeInfo((x.Node.Expression as MemberAccessExpressionSyntax)!.Expression, x.CancellationToken);
                return model.Type?.Name == "ConsoleAppBuilder";
            })
            .WithTrackingName("ConsoleApp.Builder.1_Where")
            .Collect()
            .WithComparer(CollectBuilderContextComparer.Default)
            .WithTrackingName("ConsoleApp.Builder.2_Collect");

        context.RegisterSourceOutput(builderSource, EmitConsoleAppBuilder);
    }

    public const string ConsoleAppBaseCode = """
// <auto-generated/>
#nullable enable
namespace ConsoleAppFramework;

using System;
using System.Text;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;

#if !USE_EXTERNAL_CONSOLEAPP_ABSTRACTIONS

internal interface IArgumentParser<T>
{
    static abstract bool TryParse(ReadOnlySpan<char> s, out T result);
}

internal record class ConsoleAppContext(string CommandName, string[] Arguments, object? State);

internal abstract class ConsoleAppFilter(ConsoleAppFilter next)
{
    protected readonly ConsoleAppFilter Next = next;

    public abstract Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken);
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = false)]
internal sealed class ConsoleAppFilterAttribute<T> : Attribute
    where T : ConsoleAppFilter
{
}

internal sealed class ArgumentParseFailedException(string message) : Exception(message)
{
}

#endif

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
internal sealed class FromServicesAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
internal sealed class ArgumentAttribute : Attribute
{
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
internal sealed class CommandAttribute : Attribute
{
    public string Command { get; }

    public CommandAttribute(string command)
    {
        this.Command = command;
    }
}

internal static partial class ConsoleApp
{
    public static IServiceProvider? ServiceProvider { get; set; }
    public static TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(5);
    public static System.Text.Json.JsonSerializerOptions? JsonSerializerOptions { get; set; }
    public static string? Version { get; set; }

    static Action<string>? logAction;
    public static Action<string> Log
    {
        get => logAction ??= Console.WriteLine;
        set => logAction = value;
    }

    static Action<string>? logErrorAction;
    public static Action<string> LogError
    {
        get => logErrorAction ??= (static msg => Log(msg));
        set => logErrorAction = value;
    }

    /// <summary>
    /// <para>You can pass second argument that generates new Run overload.</para>
    /// ConsoleApp.Run(args, (int x, int y) => { });<br/>
    /// ConsoleApp.Run(args, Foo);<br/>
    /// ConsoleApp.Run(args, &amp;Foo);<br/>
    /// </summary>
    public static void Run(string[] args)
    {
    }

    /// <summary>
    /// <para>You can pass second argument that generates new RunAsync overload.</para>
    /// ConsoleApp.RunAsync(args, (int x, int y) => { });<br/>
    /// ConsoleApp.RunAsync(args, Foo);<br/>
    /// ConsoleApp.RunAsync(args, &amp;Foo);<br/>
    /// </summary>
    public static Task RunAsync(string[] args)
    {
        return Task.CompletedTask;
    }

    public static ConsoleAppBuilder Create() => new ConsoleAppBuilder();

    static void ThrowArgumentParseFailed(string argumentName, string value)
    {
        throw new ArgumentParseFailedException($"Argument '{argumentName}' failed to parse, provided value: {value}");
    }

    static void ThrowRequiredArgumentNotParsed(string name)
    {
        throw new ArgumentParseFailedException($"Required argument '{name}' was not specified.");
    }

    static void ThrowArgumentNameNotFound(string argumentName)
    {
        throw new ArgumentParseFailedException($"Argument '{argumentName}' is not recognized.");
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool TryIncrementIndex(ref int index, int length)
    {
        if ((index + 1) < length)
        {
            index += 1;
            return true;
        }
        return false;
    }

    static bool TryParseParamsArray<T>(ReadOnlySpan<string> args, ref T[] result, ref int i)
       where T : IParsable<T>
    {
        result = new T[args.Length - i];
        var resultIndex = 0;
        for (; i < args.Length; i++)
        {
            if (!T.TryParse(args[i], null, out result[resultIndex++]!)) return false;
        }
        return true;
    }

    static bool TrySplitParse<T>(ReadOnlySpan<char> s, out T[] result)
       where T : ISpanParsable<T>
    {
        if (s.StartsWith("["))
        {
            try
            {
                result = System.Text.Json.JsonSerializer.Deserialize<T[]>(s, JsonSerializerOptions)!;
                return true;
            }
            catch
            {
                result = default!;
                return false;
            }
        }

        var count = s.Count(',') + 1;
        result = new T[count];

        var source = s;
        var destination = result.AsSpan();
        Span<Range> ranges = stackalloc Range[Math.Min(count, 128)];

        while (true)
        {
            var splitCount = source.Split(ranges, ',');
            var parseTo = splitCount;
            if (splitCount == 128 && source[ranges[^1]].Contains(','))
            {
                parseTo = splitCount - 1;
            }

            for (int i = 0; i < parseTo; i++)
            {
                if (!T.TryParse(source[ranges[i]], null, out destination[i]!))
                {
                    return false;
                }
            }
            destination = destination.Slice(parseTo);

            if (destination.Length != 0)
            {
                source = source[ranges[^1]];
                continue;
            }
            else
            {
                break;
            }
        }

        return true;
    }

    static void ValidateParameter(object? value, ParameterInfo parameter, ValidationContext validationContext, ref StringBuilder? errorMessages)
    {
        validationContext.DisplayName = parameter.Name ?? "";
        validationContext.Items.Clear();

        foreach (var validator in parameter.GetCustomAttributes<ValidationAttribute>(false))
        {
            var result = validator.GetValidationResult(value, validationContext);
            if (result != null)
            {
                if (errorMessages == null)
                {
                    errorMessages = new StringBuilder();
                }
                errorMessages.AppendLine(result.ErrorMessage);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static bool TryShowHelpOrVersion(ReadOnlySpan<string> args, int requiredParameterCount, int helpId)
    {
        if (args.Length == 0)
        {
            if (requiredParameterCount == 0) return false;
            
            ShowHelp(helpId);
            return true;
        }

        if (args.Length == 1)
        {
            switch (args[0])
            {
                case "--version":
                    ShowVersion();
                    return true;
                case "-h":
                case "--help":
                    ShowHelp(helpId);
                    return true;
                default:
                    break;
            }
        }

        return false;
    }

    static void ShowVersion()
    {
        if (Version != null)
        {
            Log(Version);
            return;
        }

        var asm = Assembly.GetEntryAssembly();
        var version = "1.0.0";
        var infoVersion = asm!.GetCustomAttribute<AssemblyInformationalVersionAttribute>();
        if (infoVersion != null)
        {
            version = infoVersion.InformationalVersion;
        }
        else
        {
            var asmVersion = asm!.GetCustomAttribute<AssemblyVersionAttribute>();
            if (asmVersion != null)
            {
                version = asmVersion.Version;
            }
        }
        Log(version);
    }

    static partial void ShowHelp(int helpId);

    static async Task RunWithFilterAsync(string commandName, string[] args, ConsoleAppFilter invoker)
    {
        using var posixSignalHandler = PosixSignalHandler.Register(Timeout);
        try
        {
            await Task.Run(() => invoker.InvokeAsync(new ConsoleAppContext(commandName, args, null), posixSignalHandler.Token)).WaitAsync(posixSignalHandler.TimeoutToken);
        }
        catch (Exception ex)
        {
            if (ex is OperationCanceledException)
            {
                Environment.ExitCode = 130;
                return;
            }

            Environment.ExitCode = 1;
            if (ex is ValidationException or ArgumentParseFailedException)
            {
                LogError(ex.Message);
            }
            else
            {
                LogError(ex.ToString());
            }
        }
    }

    sealed class PosixSignalHandler : IDisposable
    {
        public CancellationToken Token => cancellationTokenSource.Token;
        public CancellationToken TimeoutToken => timeoutCancellationTokenSource.Token;

        CancellationTokenSource cancellationTokenSource;
        CancellationTokenSource timeoutCancellationTokenSource;
        TimeSpan timeout;

        PosixSignalRegistration? sigInt;
        PosixSignalRegistration? sigQuit;
        PosixSignalRegistration? sigTerm;

        PosixSignalHandler(TimeSpan timeout)
        {
            this.cancellationTokenSource = new CancellationTokenSource();
            this.timeoutCancellationTokenSource = new CancellationTokenSource();
            this.timeout = timeout;
        }

        public static PosixSignalHandler Register(TimeSpan timeout)
        {
            var handler = new PosixSignalHandler(timeout);

            Action<PosixSignalContext> handleSignal = handler.HandlePosixSignal;

            handler.sigInt = PosixSignalRegistration.Create(PosixSignal.SIGINT, handleSignal);
            handler.sigQuit = PosixSignalRegistration.Create(PosixSignal.SIGQUIT, handleSignal);
            handler.sigTerm = PosixSignalRegistration.Create(PosixSignal.SIGTERM, handleSignal);

            return handler;
        }

        void HandlePosixSignal(PosixSignalContext context)
        {
            context.Cancel = true;
            cancellationTokenSource.Cancel();
            timeoutCancellationTokenSource.CancelAfter(timeout);
        }

        public void Dispose()
        {
            sigInt?.Dispose();
            sigQuit?.Dispose();
            sigTerm?.Dispose();
            timeoutCancellationTokenSource.Dispose();
        }
    }

    struct SyncAsyncDisposeWrapper<T>(T value) : IDisposable
        where T : IAsyncDisposable
    {
        public readonly T Value => value;

        public void Dispose()
        {
            value.DisposeAsync().AsTask().GetAwaiter().GetResult();
        }
    }

    internal partial struct ConsoleAppBuilder
    {
        public ConsoleAppBuilder()
        {
        }

        public void Add(string commandName, Delegate command)
        {
            AddCore(commandName, command);
        }

        [System.Diagnostics.Conditional("DEBUG")]
        public void Add<T>() { }

        [System.Diagnostics.Conditional("DEBUG")]
        public void Add<T>(string commandPath) { }

        [System.Diagnostics.Conditional("DEBUG")]
        public void UseFilter<T>() where T : ConsoleAppFilter { }

        public void Run(string[] args)
        {
            RunCore(args);
        }

        public Task RunAsync(string[] args)
        {
            Task? task = null;
            RunAsyncCore(args, ref task!);
            return task ?? Task.CompletedTask;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        partial void AddCore(string commandName, Delegate command);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        partial void RunCore(string[] args);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        partial void RunAsyncCore(string[] args, ref Task result);

        static partial void ShowHelp(int helpId);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        static bool TryShowHelpOrVersion(ReadOnlySpan<string> args, int requiredParameterCount, int helpId)
        {
            if (args.Length == 0)
            {
                if (requiredParameterCount == 0) return false;
            
                ShowHelp(helpId);
                return true;
            }

            if (args.Length == 1)
            {
                switch (args[0])
                {
                    case "--version":
                        ShowVersion();
                        return true;
                    case "-h":
                    case "--help":
                        ShowHelp(helpId);
                        return true;
                    default:
                        break;
                }
            }

            return false;
        }
    }
}
""";

    static void EmitConsoleAppTemplateSource(IncrementalGeneratorPostInitializationContext context)
    {
        context.AddSource("ConsoleApp.cs", ConsoleAppBaseCode);
    }

    const string GeneratedCodeHeader = """
// <auto-generated/>
#nullable enable
#pragma warning disable CS0108 // hides inherited member
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0219 // Variable assigned but never used
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment
#pragma warning disable CS8602
#pragma warning disable CS8604 // Possible null reference argument for parameter
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method
#pragma warning disable CS8765 // Nullability of type of parameter
#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member
#pragma warning disable CA1050 // Declare types in namespaces.
#pragma warning disable CS1998
        
namespace ConsoleAppFramework;
        
using System;
using System.Text;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;

""";

    static void EmitConsoleAppRun(SourceProductionContext sourceProductionContext, RunContext runNode)
    {
        var node = runNode.Node;
        var model = runNode.SemanticModel;

        var wellKnownTypes = new WellKnownTypes(model.Compilation);

        var parser = new Parser(sourceProductionContext, node, model, wellKnownTypes, DelegateBuildType.MakeDelegateWhenHasDefaultValue, []);
        var command = parser.ParseAndValidateForRun();
        if (command == null)
        {
            return;
        }
        if (command.HasFilter)
        {
            sourceProductionContext.ReportDiagnostic(DiagnosticDescriptors.CommandHasFilter, node.GetLocation());
            return;
        }

        var isRunAsync = ((node.Expression as MemberAccessExpressionSyntax)?.Name.Identifier.Text == "RunAsync");

        var sb = new SourceBuilder(0);
        sb.AppendLine(GeneratedCodeHeader);
        using (sb.BeginBlock("internal static partial class ConsoleApp"))
        {
            var emitter = new Emitter();
            var withId = new Emitter.CommandWithId(null, command, -1);
            emitter.EmitRun(sb, withId, isRunAsync);
        }
        sourceProductionContext.AddSource("ConsoleApp.Run.g.cs", sb.ToString());

        var help = new SourceBuilder(0);
        help.AppendLine(GeneratedCodeHeader);
        using (help.BeginBlock("internal static partial class ConsoleApp"))
        {
            var emitter = new Emitter();
            emitter.EmitHelp(help, command);
        }
        sourceProductionContext.AddSource("ConsoleApp.Run.Help.g.cs", help.ToString());
    }

    static void EmitConsoleAppBuilder(SourceProductionContext sourceProductionContext, ImmutableArray<BuilderContext> generatorSyntaxContexts)
    {
        if (generatorSyntaxContexts.Length == 0) return;

        // validation, invoke in loop is not allowed.
        foreach (var item in generatorSyntaxContexts)
        {
            if (item.Name is "Run" or "RunAsync") continue;
            foreach (var n in item.Node.Ancestors())
            {
                if (n.Kind() is SyntaxKind.WhileStatement or SyntaxKind.DoStatement or SyntaxKind.ForStatement or SyntaxKind.ForEachStatement)
                {
                    sourceProductionContext.ReportDiagnostic(DiagnosticDescriptors.AddInLoopIsNotAllowed, item.Node.GetLocation());
                    return;
                }
            }
        }

        var methodGroup = generatorSyntaxContexts.ToLookup(x =>
        {
            if (x.Name == "Add" && ((x.Node.Expression as MemberAccessExpressionSyntax)?.Name.IsKind(SyntaxKind.GenericName) ?? false))
            {
                return "Add<T>";
            }

            return x.Name;
        });

        var globalFilters = methodGroup["UseFilter"]
            .OrderBy(x => x.Node.GetLocation().SourceSpan) // sort by line number
            .Select(x =>
            {
                var genericName = (x.Node.Expression as MemberAccessExpressionSyntax)?.Name as GenericNameSyntax;
                var genericType = genericName!.TypeArgumentList.Arguments[0];
                var type = x.Model.GetTypeInfo(genericType).Type;
                if (type == null) return null!;

                var filter = FilterInfo.Create(type);

                if (filter == null)
                {
                    sourceProductionContext.ReportDiagnostic(DiagnosticDescriptors.FilterMultipleConsturtor, genericType.GetLocation());
                    return null!;
                }

                return filter!;
            })
            .ToArray();

        // don't emit if exists failure(already reported error)
        if (globalFilters.Any(x => x == null))
        {
            return;
        }

        var names = new HashSet<string>();
        var commands1 = methodGroup["Add"]
            .Select(x =>
            {
                var wellKnownTypes = new WellKnownTypes(x.Model.Compilation);
                var parser = new Parser(sourceProductionContext, x.Node, x.Model, wellKnownTypes, DelegateBuildType.OnlyActionFunc, globalFilters);
                var command = parser.ParseAndValidateForBuilderDelegateRegistration();

                // validation command name duplicate
                if (command != null && !names.Add(command.Name))
                {
                    var location = x.Node.ArgumentList.Arguments[0].GetLocation();
                    sourceProductionContext.ReportDiagnostic(DiagnosticDescriptors.DuplicateCommandName, location, command!.Name);
                    return null;
                }

                return command;
            })
            .ToArray(); // evaluate first.

        var commands2 = methodGroup["Add<T>"]
            .SelectMany(x =>
            {
                var wellKnownTypes = new WellKnownTypes(x.Model.Compilation);
                var parser = new Parser(sourceProductionContext, x.Node, x.Model, wellKnownTypes, DelegateBuildType.None, globalFilters);
                var commands = parser.ParseAndValidateForBuilderClassRegistration();

                // validation command name duplicate
                foreach (var command in commands)
                {
                    if (command != null && !names.Add(command.Name))
                    {
                        sourceProductionContext.ReportDiagnostic(DiagnosticDescriptors.DuplicateCommandName, x.Node.GetLocation(), command!.Name);
                        return [null];
                    }
                }

                return commands;
            });

        var commands = commands1.Concat(commands2).ToArray();

        // don't emit if exists failure(already reported error)
        if (commands.Any(x => x == null))
        {
            return;
        }

        if (commands.Length == 0) return;

        var hasRun = methodGroup["Run"].Any();
        var hasRunAsync = methodGroup["RunAsync"].Any();

        if (!hasRun && !hasRunAsync) return;

        var sb = new SourceBuilder(0);
        sb.AppendLine(GeneratedCodeHeader);

        // with id number
        var commandIds = commands
            .Select((x, i) =>
            {
                return new Emitter.CommandWithId(
                    FieldType: x!.BuildDelegateSignature(out _), // for builder, always generate Action/Func so ok to ignore out var.
                    Command: x!,
                    Id: i
                );
            })
            .ToArray();

        using (sb.BeginBlock("internal static partial class ConsoleApp"))
        {
            var emitter = new Emitter();
            emitter.EmitBuilder(sb, commandIds, hasRun, hasRunAsync);
        }
        sourceProductionContext.AddSource("ConsoleApp.Builder.g.cs", sb.ToString());

        // Build Help

        var help = new SourceBuilder(0);
        help.AppendLine(GeneratedCodeHeader);
        using (help.BeginBlock("internal static partial class ConsoleApp"))
        using (help.BeginBlock("internal partial struct ConsoleAppBuilder"))
        {
            var emitter = new Emitter();
            emitter.EmitHelp(help, commandIds!);
        }
        sourceProductionContext.AddSource("ConsoleApp.Builder.Help.g.cs", help.ToString());
    }

    readonly struct RunContext(InvocationExpressionSyntax node, SemanticModel model) : IEquatable<RunContext>
    {
        public InvocationExpressionSyntax Node => node;
        public SemanticModel SemanticModel => model;

        public bool Equals(RunContext other)
        {
            if (!SyntaxNodeTextEqualityComparer.Default.Equals(node.Expression, other.Node.Expression)) return false;

            return DelegateEquals(node, model, (other.Node, other.SemanticModel));
        }

        public override int GetHashCode()
        {
            // maybe this does not called so don't care impl.
            return SyntaxNodeTextEqualityComparer.Default.GetHashCode(node);
        }

        // use for both Run and Builder.Add
        public static bool DelegateEquals(InvocationExpressionSyntax node, SemanticModel model, (InvocationExpressionSyntax Node, SemanticModel SemanticModel) other)
        {
            var args1 = node.ArgumentList.Arguments;
            var args2 = other.Node.ArgumentList.Arguments;

            if (args1.Count != args2.Count) return false;
            if (args1.Count != 2) return false;

            if (args1[1].Kind() != args2[1].Kind())
            {
                return false;
            }

            var expression = args1[1].Expression;
            var lambda1 = expression as ParenthesizedLambdaExpressionSyntax;
            if (lambda1 != null)
            {
                // check async, returntype, parameters

                var lambda2 = args2[1].Expression as ParenthesizedLambdaExpressionSyntax;
                if (lambda2 == null) return false;

                if (!lambda1.AsyncKeyword.IsKind(lambda2.AsyncKeyword.Kind())) return false;

                if (!SyntaxNodeTextEqualityComparer.Default.Equals(lambda1.ReturnType!, lambda2.ReturnType!))
                {
                    return false;
                }

                return SyntaxNodeTextEqualityComparer.Default.Equals(lambda1.ParameterList, lambda2.ParameterList);
            }
            else
            {
                ImmutableArray<ISymbol> methodSymbols1;
                ImmutableArray<ISymbol> methodSymbols2;
                if (expression.IsKind(SyntaxKind.AddressOfExpression))
                {
                    var operand1 = (expression as PrefixUnaryExpressionSyntax)?.Operand;
                    var operand2 = (args2[1].Expression as PrefixUnaryExpressionSyntax)?.Operand;
                    if (operand1 == null || operand2 == null) return false;

                    methodSymbols1 = model.GetMemberGroup(operand1);
                    methodSymbols2 = other.SemanticModel.GetMemberGroup(operand2);
                }
                else
                {
                    methodSymbols1 = model.GetMemberGroup(expression);
                    methodSymbols2 = other.SemanticModel.GetMemberGroup(args2[1].Expression);
                }

                if (methodSymbols1.Length > 0 && methodSymbols1[0] is IMethodSymbol methodSymbol1)
                {
                    if (methodSymbols2.Length > 0 && methodSymbols2[0] is IMethodSymbol methodSymbol2)
                    {
                        return MethodSymbolEquals(methodSymbol1, methodSymbol2);
                    }
                }
            }

            return false;
        }

        public static bool MethodSymbolEquals(IMethodSymbol methodSymbol1, IMethodSymbol methodSymbol2)
        {
            var syntax1 = FunctionSyntax.From(methodSymbol1.DeclaringSyntaxReferences[0].GetSyntax());
            var syntax2 = FunctionSyntax.From(methodSymbol2.DeclaringSyntaxReferences[0].GetSyntax());
            if (syntax1 == null || syntax2 == null) return false;

            // document comment
            if (!SyntaxNodeTextEqualityComparer.Default.Equals(syntax1.GetDocumentationCommentTriviaSyntax()!, syntax2.GetDocumentationCommentTriviaSyntax()!))
            {
                return false;
            }

            // return type
            if (!SyntaxNodeTextEqualityComparer.Default.Equals(syntax1.ReturnType, syntax2.ReturnType))
            {
                return false;
            }

            // attributes
            if (!SyntaxNodeTextEqualityComparer.Default.Equals(syntax1.AttributeLists, syntax2.AttributeLists))
            {
                return false;
            }

            // parameters
            return SyntaxNodeTextEqualityComparer.Default.Equals(syntax1.ParameterList, syntax2.ParameterList);
        }
    }

    public class CollectBuilderContextComparer : IEqualityComparer<ImmutableArray<BuilderContext>>
    {
        public static CollectBuilderContextComparer Default = new CollectBuilderContextComparer();

        bool IEqualityComparer<ImmutableArray<BuilderContext>>.Equals(ImmutableArray<BuilderContext> x, ImmutableArray<BuilderContext> y)
        {
            if (x.Length != y.Length) return false;

            for (int i = 0; i < x.Length; i++)
            {
                if (!Equals(x[i], y[i])) return false;
            }

            return true;
        }

        int IEqualityComparer<ImmutableArray<BuilderContext>>.GetHashCode(ImmutableArray<BuilderContext> obj)
        {
            return 0;
        }


        static bool Equals(BuilderContext self, BuilderContext other)
        {
            if (self.Name != other.Name) return false;

            var typeInfo = self.Model.GetTypeInfo((self.Node.Expression as MemberAccessExpressionSyntax)!.Expression, self.CancellationToken);
            if (typeInfo.Type?.Name != "ConsoleAppBuilder")
            {
                return false;
            }

            var typeInfo2 = other.Model.GetTypeInfo((other.Node.Expression as MemberAccessExpressionSyntax)!.Expression, other.CancellationToken);
            if (typeInfo2.Type?.Name != "ConsoleAppBuilder")
            {
                return false;
            }

            switch (self.Name)
            {
                case "Add": // Add or Add<T>
                    if ((self.Node.Expression as MemberAccessExpressionSyntax)?.Name.IsKind(SyntaxKind.GenericName) ?? false)
                    {
                        return EqualsAddClass(self, other);
                    }
                    else
                    {
                        var first = GetFirstStringConstant(self.Node);
                        var second = GetFirstStringConstant(other.Node);
                        if (first == null || second == null) return false;
                        if (first != second) return false;

                        return RunContext.DelegateEquals(self.Node, self.Model, (other.Node, other.Model));
                    }
                case "UseFilter":
                    return EqualsUseFilter(self, other);
                case "Run":
                case "RunAsync":
                    return true; // only check name
                default:
                    break;
            }

            return false;
        }

        static string? GetFirstStringConstant(InvocationExpressionSyntax invocationExpression)
        {
            if (invocationExpression.ArgumentList.Arguments.Count != 2) return null;
            var commandName = invocationExpression.ArgumentList.Arguments[0];

            if (!commandName.Expression.IsKind(SyntaxKind.StringLiteralExpression))
            {
                return null;
            }

            var name = (commandName.Expression as LiteralExpressionSyntax)!.Token.ValueText;
            return name;
        }

        static bool EqualsAddClass(BuilderContext self, BuilderContext other)
        {
            var node = self.Node;
            var model = self.Model;

            var typeAndPath1 = GetTypeSymbolAndPath(node, model, self.CancellationToken);
            var typeAndPath2 = GetTypeSymbolAndPath(other.Node, other.Model, other.CancellationToken);

            if (typeAndPath1 == null || typeAndPath2 == null) return false;

            var (type1, path1) = typeAndPath1.Value;
            var (type2, path2) = typeAndPath2.Value;

            if (path1 != path2) return false;

            if (type1.DeclaringSyntaxReferences.Length == 0) return false;
            if (type2.DeclaringSyntaxReferences.Length == 0) return false;

            var syntax1 = type1.DeclaringSyntaxReferences[0].GetSyntax() as TypeDeclarationSyntax;
            var syntax2 = type2.DeclaringSyntaxReferences[0].GetSyntax() as TypeDeclarationSyntax;

            if (syntax1 == null || syntax2 == null) return false;

            // interface
            if (!type1.AllInterfaces.Select(x => x.Name).SequenceEqual(type2.AllInterfaces.Select(x => x.Name)))
            {
                return false;
            }

            // Public Constructor
            var ctor1 = type1.GetMembers().FirstOrDefault(x => (x as IMethodSymbol)?.MethodKind == Microsoft.CodeAnalysis.MethodKind.Constructor);
            var ctor2 = type2.GetMembers().FirstOrDefault(x => (x as IMethodSymbol)?.MethodKind == Microsoft.CodeAnalysis.MethodKind.Constructor);
            var ctorParameter1 = ctor1?.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax().GetParameterListOfConstructor();
            var ctorParameter2 = ctor2?.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax().GetParameterListOfConstructor();

            if (!SyntaxNodeTextEqualityComparer.Default.Equals(ctorParameter1, ctorParameter2))
            {
                return false;
            }

            // attributes
            if (!SyntaxNodeTextEqualityComparer.Default.Equals(syntax1.AttributeLists!, syntax2.AttributeLists!))
            {
                return false;
            }

            // Public Methods
            var methods1 = GetMethodSymbols(type1);
            var methods2 = GetMethodSymbols(type2);
            var methodEquals = methods1.ZipEquals(methods2, RunContext.MethodSymbolEquals);
            return methodEquals;

            static (ITypeSymbol, string?)? GetTypeSymbolAndPath(InvocationExpressionSyntax node, SemanticModel model, CancellationToken cancellationToken)
            {
                // Add<T>
                var genericName = (node.Expression as MemberAccessExpressionSyntax)?.Name as GenericNameSyntax;
                var genericType = genericName!.TypeArgumentList.Arguments[0];

                // Add<T>(string commandPath)
                string? commandPath = null;
                var args = node.ArgumentList.Arguments;
                if (node.ArgumentList.Arguments.Count == 1)
                {
                    var commandName = args[0];
                    if (!commandName.Expression.IsKind(SyntaxKind.StringLiteralExpression))
                    {
                        return null;
                    }

                    commandPath = (commandName.Expression as LiteralExpressionSyntax)!.Token.ValueText;
                }

                // T
                var type = model.GetTypeInfo(genericType, cancellationToken).Type!;
                return (type, commandPath);
            }

            static IEnumerable<IMethodSymbol> GetMethodSymbols(ITypeSymbol type)
            {
                return type.GetMembers()
                  .OfType<IMethodSymbol>()
                  .Where(x => x.DeclaredAccessibility == Accessibility.Public && !x.IsStatic)
                  .Where(x => x.MethodKind == Microsoft.CodeAnalysis.MethodKind.Ordinary)
                  .Where(x => !(x.Name is "Dispose" or "DisposeAsync" or "GetHashCode" or "Equals" or "ToString"));
            }
        }

        static bool EqualsUseFilter(BuilderContext self, BuilderContext other)
        {
            var node = self.Node;
            var model = self.Model;

            var l = GetType(node, model, self.CancellationToken);
            var r = GetType(other.Node, other.Model, other.CancellationToken);

            return l.EqualsNamespaceAndName(r);

            static ITypeSymbol? GetType(InvocationExpressionSyntax expression, SemanticModel model, CancellationToken cancellationToken)
            {
                var genericName = (expression.Expression as MemberAccessExpressionSyntax)?.Name as GenericNameSyntax;
                var genericType = genericName!.TypeArgumentList.Arguments[0];
                return model.GetTypeInfo(genericType, cancellationToken).Type;
            }
        }
    }

    readonly struct BuilderContext(InvocationExpressionSyntax node, string name, SemanticModel model, CancellationToken cancellationToken) : IEquatable<BuilderContext>
    {
        public InvocationExpressionSyntax Node => node;
        public string Name => name;
        public SemanticModel Model => model;
        public CancellationToken CancellationToken => cancellationToken;

        public bool Equals(BuilderContext other)
        {
            return Node == other.Node;
        }
    }
}